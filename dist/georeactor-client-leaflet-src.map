{"version":3,"sources":["src/../scripts/georeactor-client.js","src/../scripts/georeactor-leaflet.js"],"names":[],"mappings":";;;;yCAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["if (typeof console === 'undefined') {\n  console = {\n    log: function() {},\n    error: function() {}\n  }\n}\n\n// Array.forEach and Array.map for TopoJSON to work in old browsers\nif (!Array.prototype.forEach) {\n  Array.prototype.forEach = function(fn,scope){\n    var i, len;\n    for (i = 0, len = this.length; i < len; ++i) {\n      if(i in this){\n        fn.call(scope, this[i], i, this);\n      }\n    }\n  };\n}\nif (!('map' in Array.prototype)) {\n  Array.prototype.map= function(mapper, that /*opt*/) {\n    var other= new Array(this.length);\n    for (var i= 0, n= this.length; i<n; i++)\n      if (i in this)\n        other[i]= mapper.call(that, this[i], i, this);\n    return other;\n  };\n}\n\n(window || global).georeactor = function() {\n  console.error('GEOREACTOR: no maps library was added');\n};\n(window || global).GEOREACTOR = {\n  data: [],\n  options: {},\n  valuesForField: {},\n  _: { }\n};\n\n(function() {\n  var globalBounds;\n\n  function makeRequestFor(datafile, callback) {\n    // XMLHttpRequest without jQuery\n    var df = datafile;\n    var request = new XMLHttpRequest();\n    request.open('GET', datafile, true);\n\n    request.onreadystatechange = function() {\n      if (this.readyState === 4) {\n        if (this.status >= 200 && this.status < 400) {\n          // consume GeoJSON or TopoJSON file\n          var gj = null;\n          var datafile = df.toLowerCase();\n          if (datafile.indexOf('topojson') > -1 || datafile.indexOf('topo.json') > -1) {\n            var tj = JSON.parse(this.responseText);\n            var key = Object.keys(tj.objects)[0];\n            gj = topojson.feature(tj, tj.objects[key]);\n          } else if (datafile.indexOf('geojson') > -1 || datafile.indexOf('geo.json') > -1) {\n            gj = JSON.parse(this.responseText);\n          } else {\n            throw 'data type unknown: ' + datafile;\n          }\n\n          // get info on bounds and properties for each data file\n          gj.features.map(function(feature) {\n            var keys = Object.keys(feature.properties);\n            keys.map(function(key) {\n              var val = feature.properties[key];\n              if (!GEOREACTOR.valuesForField[key]) {\n                GEOREACTOR.valuesForField[key] = {\n                  min: val,\n                  max: val,\n                  nonZeroCount: 0\n                };\n              }\n              if (val < GEOREACTOR.valuesForField[key].min) {\n                GEOREACTOR.valuesForField[key].min = val;\n              }\n              if (val > GEOREACTOR.valuesForField[key].max) {\n                GEOREACTOR.valuesForField[key].max = val;\n              }\n              if (val) {\n                GEOREACTOR.valuesForField[key].nonZeroCount++;\n              }\n            });\n\n            var bounds = makeBounds(feature.geometry.coordinates);\n            feature.properties.bounds = bounds;\n            if (!globalBounds) {\n              globalBounds = bounds;\n            } else {\n              globalBounds[0] = Math.min(globalBounds[0], bounds[0]);\n              globalBounds[1] = Math.min(globalBounds[1], bounds[1]);\n              globalBounds[2] = Math.max(globalBounds[2], bounds[2]);\n              globalBounds[3] = Math.max(globalBounds[3], bounds[3]);\n            }\n          });\n          GEOREACTOR._.fitBounds(globalBounds);\n\n          callback(gj);\n        } else {\n          console.log('failed to do XMLHttpRequest');\n        }\n      }\n    };\n    request.send();\n  }\n\n  function makeBounds(coordinates, existing) {\n    if (!existing) {\n      existing = [180, 90, -180, -90];\n    }\n    if (typeof coordinates[0] === 'number') {\n      existing[0] = Math.min(existing[0], coordinates[0]);\n      existing[1] = Math.min(existing[1], coordinates[1]);\n      existing[2] = Math.max(existing[2], coordinates[0]);\n      existing[3] = Math.max(existing[3], coordinates[1]);\n    } else {\n      for (var c = 0; c < coordinates.length; c++) {\n        existing = makeBounds(coordinates[c], existing);\n      }\n    }\n    return existing;\n  }\n\n  GEOREACTOR.commonDataLoader = function() {\n    if (GEOREACTOR.options.data.length === 0) {\n      console.log('GEOREACTOR: no datasets to load');\n    }\n    GEOREACTOR.options.data.map(function(dataset) {\n      makeRequestFor(dataset, function (gj) {\n        GEOREACTOR._.mapJSONfile(gj);\n      });\n    });\n  };\n})();\n","(function() {\n  if (typeof GEOREACTOR === 'undefined') {\n    console.error('GEOREACTOR: georeactor-client.js must be loaded for georeactor-leaflet to work');\n    return;\n  }\n  GEOREACTOR.library = 'leaflet';\n\n  var map, clickCircle;\n\n  GEOREACTOR._.mapJSONfile = function(gj) {\n    dataLayer = L.geoJson(gj, {\n      style: function (feature) {\n        return {\n          fillColor: '#f00',\n          fillOpacity: 0,\n          color: '#444',\n          weight: 2\n        }\n      },\n      onEachFeature: function (feature, layer) {\n        if (GEOREACTOR.options.popups) {\n          var banProperties = ['bounds'];\n          var propKeys = Object.keys(feature.properties);\n          var txtTable = '<table>';\n          propKeys.map(function(key) {\n            if (banProperties.indexOf(key) > -1) {\n              return;\n            }\n            txtTable += '<tr><td>' + key + '</td><td>' + feature.properties[key] + '</td></tr>';\n          });\n          txtTable += '</table>';\n          layer.bindPopup(txtTable);\n        }\n        layer.on('click', function() {\n          if (typeof GEOREACTOR.initReact === 'function') {\n            GEOREACTOR.initReact();\n          }\n\n          if (clickCircle) {\n            map.removeLayer(clickCircle);\n          }\n\n          if(feature.geometry.type === 'Point') {\n            var coord = feature.geometry.coordinates.concat([]);\n            coord.reverse();\n            clickCircle = L.circleMarker(coord, {\n              radius: 80,\n              strokeColor: '#f00',\n              fillColor: '#f00'\n            }).addTo(map);\n          }\n\n          GEOREACTOR._.fitBounds(feature.properties.bounds);\n          GEOREACTOR.selectFeature = feature;\n          if (GEOREACTOR._.detailView) {\n            GEOREACTOR._.detailView.setState({ selectFeature: feature });\n          }\n          dataLayer.setStyle(function (styler) {\n            var fillOpacity = 0;\n            if (feature === styler) {\n              fillOpacity = 0.2;\n            }\n            return {\n              fillColor: '#f00',\n              fillOpacity: fillOpacity,\n              color: '#444',\n              weight: 1\n            }\n          });\n        });\n      }\n    }).addTo(map);\n    return dataLayer;\n  };\n\n  georeactor = function(options) {\n    GEOREACTOR.options = options;\n\n    map = L.map(options.div || 'map')\n      .setView([(options.lat || 0), (options.lng || options.lon || 0)], (options.zoom || 5));\n    map.attributionControl.setPrefix('');\n    if (typeof L.Hash === 'function') {\n      new L.Hash(map);\n    }\n\n    if (!GEOREACTOR.options.tiles || !GEOREACTOR.options.tiles.length) {\n      var osm = L.tileLayer('//tile-{s}.openstreetmap.fr/hot/{z}/{x}/{y}.png', {\n        attribution: 'Map data &copy; OpenStreetMap contributors',\n        maxZoom: 17\n      }).addTo(map);\n      var sat = L.tileLayer('//{s}.tiles.mapbox.com/v3/mapmeld.map-a6ineq7y/{z}/{x}/{y}.png?updated=65f7243', {\n        attribution: 'Map data &copy; OpenStreetMap contributors; satellite from MapBox',\n        maxZoom: 17\n      });\n      L.control.layers({\n        \"OpenStreetMap\": osm,\n        \"Satellite\": sat\n      }, {}).addTo(map);\n\n      map.on('baselayerchange', function() {\n        /* update default lines */\n      });\n    } else {\n      /* custom tiles */\n      if (typeof GEOREACTOR.options.tiles === 'string') {\n        L.tileLayer(GEOREACTOR.options.tiles, {\n          maxZoom: 17\n        }).addTo(map);\n      } else {\n        var layers = {};\n        GEOREACTOR.options.tiles.forEach(function(layer, i) {\n          layer = L.tileLayer(layer, {\n            maxZoom: 17\n          }).addTo(map);\n          layers['ABCDEFGHIJKLMNOPQRSTUVWXYZ'[i]] = layer;\n        });\n        L.control.layers(layers, {}).addTo(map);\n      }\n    }\n\n    var layerControl = document.getElementsByClassName(\"leaflet-control-layers-toggle\");\n    if (layerControl.length) {\n      setTimeout(function() {\n        layerControl[0].style.backgroundImage = 'url(styles/lib/images/layers.png)';\n      }, 200);\n    }\n\n    GEOREACTOR._.fitBounds = function(bounds) {\n      map.fitBounds(L.latLngBounds(\n        L.latLng(bounds[1], bounds[0]),\n        L.latLng(bounds[3], bounds[2])\n      ));\n    }\n\n    GEOREACTOR.commonDataLoader();\n\n    if (typeof GEOREACTOR.initReact === 'function') {\n      GEOREACTOR.initReact();\n    }\n  };\n})();\n"]}